!3 Why mock?
Consider a system ("our" system), which is being tested. It makes web service calls to other systems, to gather data or have an impact on those other systems.

It can be difficult to test our system when we don't have complete control of those other systems. Even if we can set up those other systems to respond appropriately, it can be a pain to coordinate. So often we're forced to test in the context of those other systems, making use of their current data. That brings its own problems. And it may be difficult to force those other systems to respond in odd ways (eg, with obscure errors), so it makes it very difficult to test our error-handling. For example, does our system react correctly, such as informing the user, if another system is unavailable for a few seconds.

There may also be problems with calling a web service that has serious impacts, such as carrying out a credit card payment.

A reasonable approach to these problems is to mock the web service to each of those other systems. This means that the test defines how another system should respond. Because the test is written to test certain behaviour, it's often OK to work out what specific ways the other systems should respond. There are techniques that help in defining the mock behaviour, as we discuss in ^MockWebServicesDocs. We also highlight some of the (fundamental) limitations of this approach.
#
----!2 Mock Web Services
''!-MockWebServicesFixture-!'' allows one or more web services to be defined.
#
!3 1. Mocking web services
We make use of a fixture that allows us to define mock web services, ''!-fitlibrary.ws.MockWebServicesFixture-!''.

We start simply, and build up to more complex scenarios in the following examples.
#
!3 2. Simply repond
Consider if we are to mock a web service that returns the available stock count for a specified item. For our first test, there will be a single request for oranges and a single response of "44". We need to configure our system so that it goes to http://localhost:8081. That assumes that the system is running on the same computer; if not the url will be for another host.

For a start, we'll ignore the details of the request and simply specify the response.

Eg:

!|fitlibrary.ws.MockWebServicesFixture|

|''mock on port''|8081|
|''response''|<count>44</count>|

... some other tables that run our system. Eg, it may check that the UI displays that there are 44 oranges.

At the end of the storytest, we close the mock web server. It will report an error if no request was received on port 8081 or unexpected requests were received.

|''close''|

But what happens if it asks for apples instead? We still return 44. We can ensure that the request is as expected...
#
!3 3. Matching the request
Let's extend the second table, as follow:

|''mock on port''|8081|
|''equals request''|oranges|
|''response''|<count>44</count>|

Now, the response of 44 will only be sent if the request exactly matches "oranges". If the request doesn't match, an error (404) is returned.
#
!3 4. Matching the request
Let's change the table to pattern match, as follow:

|''mock on port''|8081|
|''matches request''|or..ges|
|''response''|<count>44</count>|

Now, the response of 44 will only be sent if the request matches the pattern "or..ges". If the request doesn't match, an error (404) is returned.

But what if there are several requests, because our system checks regularly for the stock count...
#
!3 5. A Sequence of Responses for a Request
We can handle a sequence of requests for the stock count for oranges, where the count may change on each request. We extend the second table, as follows:

|''mock on port''|8081|
|''matches request''|<item>oranges</item>|
|''response''|<count>44</count>|
|''response''|<count>23</count>|
|''response''|<count>10</count>|
|''response''|<count>0</count>|

|''close''|

Now, our system will get back responses from 4 requests for oranges: 44, 23, 10, 0.

The close will fail if 4 requests for oranges have not been received.
#
!3 6. Alternative requests
So far, we've assumed that we're only interested in a specific request. What if we want to provide counts for apples and oranges? We can do that with two table, as follows:

!|fitlibrary.ws.MockWebServicesFixture|

|''mock on port''|8081|
|''matches request''|<item>oranges</item>|
|''response''|<count>44</count>|
|''response''|<count>23</count>|

|''mock on port''|8081|
|''matches request''|<item>apples</item>|
|''response''|<count>17</count>|
|''response''|<count>9</count>|

When a request comes in, it's matched against the first table. As that doesn't match, it's then matched against the second table.

This means that we don't care which order the requsts for apples and oranges come in. Once a response has been used, it's not used again. So we could end up with the following alternative sequences of requests/responses:

 * (oranges/44), (oranges/23), (apples/17), (apples/9) '''or'''
 * (oranges/44), (apples/17), (oranges/23), (apples/9) '''or'''
 * (oranges/44), (apples/17), (apples/9), (oranges/23)  '''or''', etc...

That is, the two tables define a partial order, with a complete order within a single table.
#
!3 7. Ordering the requests
If we really want to constrain the order of the requests for oranges and apples, we can do that within a single table.

|''mock on port''|8081|
|''matches request''|<item>oranges</item>|
|''response''|<count>44</count>|
|''response''|<count>23</count>|
|''then''|
|''matches request''|<item>apples</item>|
|''response''|<count>17</count>|
|''response''|<count>9</count>|

This will only match the following sequence of calls:

 * (oranges/44), (oranges/23), (apples/17), (apples/9)
#
!3 8. Repeating a response
What if we want the last reponse to be repeated, any nu,ber of times. Eg, once the count of oranges gets to 0, it stays at that count:

|''mock on port''|8081|
|''matches request''|<item>oranges</item>|
|''response''|<count>44</count>|
|''response''|<count>23</count>|
|''response''|<count>10</count>|
|''response''|<count>0</count>|
|''repeat''|

|''close''|

This will provide a sequence of responses of: 44, 23, 10, 0, 0, 0, ...

An error will be given if there are fewer than three requests for orange counts, but four or more are permitted.
#
!3 9. Several services on the same port
Where there are several web services on the same port, we can distinguish between them. For example:

|''mock on port''|8081|
|''matches URL''|/stockCount|
|''matches request''|<item>oranges</item>|
|''response''|<count>10</count>|

|''mock on port''|8081|
|''matches URL''|/creditRating|
|''matches request''|<user>123122134</user>|
|''response''|<rating>90</rating>|

Then an incoming request is matched against the URL as well as the contents of the request.
#
!3 10. Matching parts of xml
The response may depend on the details within the request. Xpaths can be used to match a request. For example:

|''mock soap on port''|8081|
|''xpath''|//name[@a="st"]|''is''|street|
|''xpath''|//address[@id="add"]|''is''|fanshawe|
|''response''|<response>out</response>|

Both xpaths in the table above have to match before the response will be used.
#
!3 11. Inserting a matcher to dynamically change the behaviour of the mock web services
Consider a test in which we want to change the number of oranges available at a specific point in the test.  We can do that by inserting a new matcher at the start of the matchers so that it will be applied first.

Eg:
|''mock on port''|8081|
|''matches request''|<item>oranges</item>|
|''response''|<count>0</count>|
|''repeat''|

... later in the storytest, so that the next request for orange count will return 10, irrespecive of what other matchers specify
|''mock on port''|8081|
|''matches request''|<item>oranges</item>|
|''response''|<count>10</count>|
|''insert''|
|''repeat''|
#
!3 12. Gathering the data for the Mock Web Services
#
See <FitLibraryWeb.RecordWebServicesDocs for details
#
!3 13. Templating mechanisms
Once a few tests have been written to mock web services, you'll find some repetition. Rather than having a lot of sinmilar responses, it makes sense to use a templating approach to building the xml in the response.

See <FitLibraryWeb.TemplateFixture and <FitLibraryWeb.TemplateFixture.TemplateFixtureDocs.
#
!3 14. Some potential limitations
 * The only way to specify that a certain response should be returned a fixed number of times is to include it that many times. It might be useful to have a repeat number on a response
 * It's not possible to specify that a certain response should be returned until a certain time has elapsed; thereafter the next response applies.

